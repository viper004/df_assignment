REFLECTION

This project helped me understand the concept of cache memory by implementing the FIFO (First-In First-Out) replacement policy through software logic. In theory, FIFO replaces the cache block that was inserted first, regardless of how frequently or recently it was accessed. In the program, this behavior was implemented using queue data structures. Each cache set maintained a FIFO queue that stored the order of inserted cache lines. When a cache miss occurred and the cache was full, the block at the front of the queue was removed (dequeued), and the new block was added at the rear (enqueued). This software-based implementation clearly demonstrated how FIFO works internally and how cache hits and misses are handled in real systems.

Git played an important role in collaborative coding and version management during the project. By creating separate branches, team members could work independently on different parts of the cache simulator such as FIFO logic, input handling, and output formatting. Git commands like commit, push, pull, and merge helped track changes and combine work efficiently. Git also allowed us to revert to earlier versions when errors occurred, making debugging easier and safer.

One of the major challenges faced was correctly maintaining the FIFO order during cache replacement, especially when handling empty cache lines and multiple sets. Resolving merge conflicts in Git was also challenging at first. Through this project, I learned the importance of proper data structures, clean code, frequent commits, and effective teamwork. Overall, this assignment improved my understanding of cache memory concepts and strengthened my practical skills in collaborative software development.